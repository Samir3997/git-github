import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.boot.test.context.SpringBootTest;
import com.maybank.ilm.core.dao.KAccountConfigRepo;
import com.maybank.ilm.core.dao.AccountBalanceAggrRepo;
import com.maybank.ilm.dto.KAccountRedemptionDTO;
import com.maybank.ilm.entity.KAccountConfiguration;
import com.maybank.ilm.entity.AccountBalanceAggregation;

@SpringBootTest
public class KAccountRedemptionEntriesTest {

    @InjectMocks
    private MXMsgHandlerAbstractImpl mxMsgHandlerAbstractImpl;

    @Mock
    private KAccountConfigRepo kAccountConfigRepo;

    @Mock
    private AccountBalanceAggrRepo accountBalanceAggrRepo;

    // Test case 1: Normal scenario with successful redemption
    @Test
    public void testGetKAccountRedemptionEntries_Success() {
        // Set up mock data
        Long countrySkey = 1L;
        Long entitySkey = 2L;
        Long currSkey = 3L;
        LocalDate valueDt = LocalDate.now();
        BigDecimal msgAmnt = BigDecimal.valueOf(1000);
        Long mainAcctEamSkey = 4L;
        Long kAcctEamSkey = 5L;

        KAccountConfiguration kAccountConfig = new KAccountConfiguration();
        kAccountConfig.setTrancheSize(BigDecimal.valueOf(500));

        AccountBalanceAggregation latestKAcctAggr = new AccountBalanceAggregation();
        latestKAcctAggr.setTotalAmnt(BigDecimal.valueOf(2000));

        // Mock repository behavior
        Mockito.when(kAccountConfigRepo.findByCountrySkeyAndEntitySkeyAndCurrencySkeyAndEffectiveFromLessThanEqualAndEffectiveToGreaterThanEqual(countrySkey, entitySkey, currSkey, valueDt, valueDt))
                .thenReturn(List.of(kAccountConfig));
        Mockito.when(accountBalanceAggrRepo.getLastUpdatedAcctBalAggr(kAcctEamSkey, valueDt, Mockito.anyString()))
                .thenReturn(latestKAcctAggr);

        // Call the method
        Map<Long, BigDecimal> amountsMap = mxMsgHandlerAbstractImpl.getKAccountRedemptionEntries(countrySkey, entitySkey, currSkey, valueDt, msgAmnt, mainAcctEamSkey, kAcctEamSkey);

        // Assert the results
        assertEquals(2, amountsMap.size());
        assertEquals(BigDecimal.valueOf(500), amountsMap.get(mainAcctEamSkey));
        assertEquals(BigDecimal.valueOf(-500), amountsMap.get(kAcctEamSkey));
    }

    // Test case 2: Scenario with insufficient balance
    @Test
    public void testGetKAccountRedemptionEntries_InsufficientBalance() {
        // ... similar setup as test case 1, but with insufficient balance in latestKAcctAggr
        // Assert that the amountsMap values are zero or appropriate based on the scenario
    }

    // Test case 3: Scenario with null values
    @Test
    public void testGetKAccountRedemptionEntries_NullValues() {
        // ... test with null values for kAcctEamSkey, latestKAcctAggr, or kAcctConfigs
        // Assert that the method handles null values gracefully
    }

    // ... Add more test cases to cover different scenarios, such as:
    // - Multiple KAccountConfigurations
    // - Different message amounts
    // - Edge cases like zero tranche size, negative balances, etc.
}
