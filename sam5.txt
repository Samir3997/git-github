import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.maybank.ilm.core.dao.AccountBalanceAggrRepo;
import com.maybank.ilm.core.dao.KAccountConfigRepo;
import com.maybank.ilm.entity.AccountBalanceAggregation;
import com.maybank.ilm.entity.KAccountConfiguration;

public class MXMsgHandlerAbstractImplTest {

    @InjectMocks
    private MXMsgHandlerAbstractImpl mxMsgHandlerAbstractImpl;

    @Mock
    private KAccountConfigRepo kAccountConfigRepo;

    @Mock
    private AccountBalanceAggrRepo aggrRepo;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testGetKAccountRedemptionEntries_NoKAccountConfig() {
        // Arrange
        Long countrySkey = 1L;
        Long entitySkey = 2L;
        Long currSkey = 3L;
        LocalDate valueDt = LocalDate.now();
        BigDecimal msgAmnt = new BigDecimal("100.00");
        Long mainAcctEamSkey = 4L;
        Long kAcctEamSkey = 5L;

        when(kAccountConfigRepo.findByCountrySkeyAndEntitySkeyAndCurrencySkeyAndEffectiveFromLessThanEqualAndEffectiveToGreaterThanEqual(countrySkey, entitySkey, currSkey, valueDt, valueDt)).thenReturn(new ArrayList<>());

        // Act
        Map<Long, BigDecimal> amountsMap = mxMsgHandlerAbstractImpl.getKAccountRedemptionEntries(countrySkey, entitySkey, currSkey, valueDt, msgAmnt, mainAcctEamSkey, kAcctEamSkey);

        // Assert
        assertEquals(0, amountsMap.size(), "No KAccountConfiguration found, amountsMap should be empty");
    }

    @Test
    public void testGetKAccountRedemptionEntries_NoLatestAggr() {
        // Arrange
        Long countrySkey = 1L;
        Long entitySkey = 2L;
        Long currSkey = 3L;
        LocalDate valueDt = LocalDate.now();
        BigDecimal msgAmnt = new BigDecimal("100.00");
        Long mainAcctEamSkey = 4L;
        Long kAcctEamSkey = 5L;

        List<KAccountConfiguration> kAcctConfigs = new ArrayList<>();
        KAccountConfiguration kAccountConfiguration = new KAccountConfiguration();
        kAccountConfiguration.setTrancheSize(new BigDecimal("50.00"));
        kAcctConfigs.add(kAccountConfiguration);

        when(kAccountConfigRepo.findByCountrySkeyAndEntitySkeyAndCurrencySkeyAndEffectiveFromLessThanEqualAndEffectiveToGreaterThanEqual(countrySkey, entitySkey, currSkey, valueDt, valueDt)).thenReturn(kAcctConfigs);
        when(aggrRepo.getLastUpdatedAcctBalAggr(kAcctEamSkey, valueDt)).thenReturn(null);

        // Act
        Map<Long, BigDecimal> amountsMap = mxMsgHandlerAbstractImpl.getKAccountRedemptionEntries(countrySkey, entitySkey, currSkey, valueDt, msgAmnt, mainAcctEamSkey, kAcctEamSkey);

        // Assert
        assertEquals(0, amountsMap.size(), "No latest aggregation found, amountsMap should be empty");
    }

    @Test
    public void testGetKAccountRedemptionEntries_RedemptionAmountLessThanTrancheSize() {
        // Arrange
        Long countrySkey = 1L;
        Long entitySkey = 2L;
        Long currSkey = 3L;
        LocalDate valueDt = LocalDate.now();
        BigDecimal msgAmnt = new BigDecimal("40.00");
        Long mainAcctEamSkey = 4L;
        Long kAcctEamSkey = 5L;

        List<KAccountConfiguration> kAcctConfigs = new ArrayList<>();
        KAccountConfiguration kAccountConfiguration = new KAccountConfiguration();
        kAccountConfiguration.setTrancheSize(new BigDecimal("50.00"));
        kAcctConfigs.add(kAccountConfiguration);

        AccountBalanceAggregation latestKAcctAggr = new AccountBalanceAggregation();
        latestKAcctAggr.setTotalAmnt(new BigDecimal("200.00"));

        when(kAccountConfigRepo.findByCountrySkeyAndEntitySkeyAndCurrencySkeyAndEffectiveFromLessThanEqualAndEffectiveToGreaterThanEqual(countrySkey, entitySkey, currSkey, valueDt, valueDt)).thenReturn(kAcctConfigs);
        when(aggrRepo.getLastUpdatedAcctBalAggr(kAcctEamSkey, valueDt)).thenReturn(latestKAcctAggr);

        // Act
        Map<Long, BigDecimal> amountsMap = mxMsgHandlerAbstractImpl.getKAccountRedemptionEntries(countrySkey, entitySkey, currSkey, valueDt, msgAmnt, mainAcctEamSkey, kAcctEamSkey);

        // Assert
        assertEquals(2, amountsMap.size(), "Amounts map should have two entries");
        assertEquals(new BigDecimal("-40.00"), amountsMap.get(kAcctEamSkey), "New KAccount outstanding balance should be -40.00");
        assertEquals(new BigDecimal("60.00"), amountsMap.get(mainAcctEamSkey), "Main account balance should be 60.00");
    }

    @Test
    public void testGetKAccountRedemptionEntries_RedemptionAmountGreaterThanTrancheSizeButLessThanOutstandingBalance() {
        // Arrange
        Long countrySkey = 1L;
        Long entitySkey = 2L;
        Long currSkey = 3L;
        LocalDate valueDt = LocalDate.now();
        BigDecimal msgAmnt = new BigDecimal("120.00");
        Long mainAcctEamSkey = 4L;
        Long kAcctEamSkey = 5L;

        List<KAccountConfiguration> kAcctConfigs = new ArrayList<>();
        KAccountConfiguration kAccountConfiguration = new KAccountConfiguration();
        kAccountConfiguration.setTrancheSize(new BigDecimal("50.00"));
        kAcctConfigs.add(kAccountConfiguration);

        AccountBalanceAggregation latestKAcctAggr = new AccountBalanceAggregation();
        latestKAcctAggr.setTotalAmnt(new BigDecimal("200.00"));

        when(kAccountConfigRepo.findByCountrySkeyAndEntitySkeyAndCurrencySkeyAndEffectiveFromLessThanEqualAndEffectiveToGreaterThanEqual(countrySkey, entitySkey, currSkey, valueDt, valueDt)).thenReturn(kAcctConfigs);
        when(aggrRepo.getLastUpdatedAcctBalAggr(kAcctEamSkey, valueDt)).thenReturn(latestKAcctAggr);

        // Act
        Map<Long, BigDecimal> amountsMap = mxMsgHandlerAbstractImpl.getKAccountRedemptionEntries(countrySkey, entitySkey, currSkey, valueDt, msgAmnt, mainAcctEamSkey, kAcctEamSkey);

        // Assert
        assertEquals(2, amountsMap.size(), "Amounts map should have two entries");
        assertEquals(new BigDecimal("-150.00"), amountsMap.get(kAcctEamSkey), "New KAccount outstanding balance should be -150.00");
        assertEquals(new BigDecimal("30.00"), amountsMap.get(mainAcctEamSkey), "Main account balance should be 30.00");
    }

    @Test
    public void testGetKAccountRedemptionEntries_RedemptionAmountGreaterThanOutstandingBalance() {
        // Arrange
        Long countrySkey = 1L;
        Long entitySkey = 2L;
        Long currSkey = 3L;
        LocalDate valueDt = LocalDate.now();
        BigDecimal msgAmnt = new BigDecimal("300.00");
        Long mainAcctEamSkey = 4L;
        Long kAcctEamSkey = 5L;

        List<KAccountConfiguration> kAcctConfigs = new ArrayList<>();
        KAccountConfiguration kAccountConfiguration = new KAccountConfiguration();
        kAccountConfiguration.setTrancheSize(new BigDecimal("50.00"));
        kAcctConfigs.add(kAccountConfiguration);

        AccountBalanceAggregation latestKAcctAggr = new AccountBalance
