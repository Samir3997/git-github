
http://10.172.120.19:8013/ilm-web/fund/position

{"endDate":"04-11-2024","entitySkey":1,"rank":"2","startDate":"04-11-2024","countrySkey":1,"currencySkey":41,"nostroBankSkey":21,"entityAccountType":"Main Account"}




{
    "timeSpendsInSeconds": 1,
    "status": "SUCCESS",
    "serviceName": "findFundPosition",
    "t": {
        "LARGEST_NEGATIVE": {
            "entityAcctMapSkeyK": null,
            "rank": null,
            "startDate": null,
            "endDate": null,
            "order": null,
            "countrySkey": null,
            "entitySkey": null,
            "currencySkey": null,
            "entityAcctMapSkeyMain": null,
            "avgPositive": null,
            "avgNegative": 0.00,
            "aggrs": [],
            "allAggrs": [],
            "nostroBankSkey": null,
            "entityAccountType": null
        },
        "LARGEST_POSITIVE": {
            "entityAcctMapSkeyK": null,
            "rank": null,
            "startDate": null,
            "endDate": null,
            "order": null,
            "countrySkey": null,
            "entitySkey": null,
            "currencySkey": null,
            "entityAcctMapSkeyMain": null,
            "avgPositive": 0.00,
            "avgNegative": null,
            "aggrs": [
                {
                    "acctBalAggrSkey": 101639,
                    "entityAcctMapSkey": 21,
                    "totalAmnt": 92.57865528,
                    "businessDtTime": "05-11-2024 12:30:00 AM",
                    "valueDate": "04-11-2024",
                    "totalInFlowAmnt": 0,
                    "totalOutFlowAmnt": 0,
                    "totalInFlowAmntSecurities": null,
                    "totalOutFlowAmntSecurities": null,
                    "aggrInd": "OTHERS",
                    "openingClosingBalInd": "CLOSING_BALANCE",
                    "trackerID": 324437,
                    "rnk": null,
                    "srrClosingBalance": 0.0,
                    "srrDailyPercentage": 0.0,
                    "calculatedDailySrrPercentage": 0.0,
                    "cashBalance": null,
                    "securitiesBalance": null,
                    "srrExcessBalance": null
                }
            ],
            "allAggrs": [],
            "nostroBankSkey": null,
            "entityAccountType": null
        }
    }
}

@Controller
@RequestMapping("/")
public class PaymentMessageController {
@PostMapping(value="/fund/position")
	@ResponseBody
	@CrossOrigin("${cors.urls}")
	public ResponseEntity<CommonResponseEntity<Map<String, FundPositionDto>>> findFundPosition(@RequestBody FundPositionDto positionDto) {
		Map<String, FundPositionDto> aggregations=paymentMessageService.findFundPosition(positionDto);
		return new ResponseEntity<>(new CommonResponseEntity<Map<String, FundPositionDto>>(1l, success, "findFundPosition", aggregations),HttpStatus.OK);
	}
}

public interface PaymentMessageService {
	public Map<String, FundPositionDto> findFundPosition(FundPositionDto positionDto);
}

@Service
public class PaymentMessageServiceImpl extends IlmAbstractCommonService implements PaymentMessageService {
@Override
	@Find(arguments= {"Fund Position DTO"},returnType="map of Acct Bal Aggr",type="JSON",comment="find_fund_position")
	@FindNormEx
	public Map<String, FundPositionDto> findFundPosition(FundPositionDto positionDto) {
		Map<String, FundPositionDto> cumulativePositions = new HashMap<>();
		List<EntityAccountMapDefinition> mainEAMDefns = new ArrayList();
		if(positionDto.getNostroBankSkey()==null) {
			mainEAMDefns = eamRepo.findByEntitySkeyAndAccountType(positionDto.getEntitySkey(), positionDto.getEntityAccountType());
		}
		else {
			mainEAMDefns = eamRepo.findByEntityAcctMapSkey(positionDto.getNostroBankSkey());
		}
		LocalDate startDate = positionDto.getStartDate();
		LocalDate endDate = positionDto.getEndDate();
		List<LocalDate> holidaysList = holidayRepo.getHolidayDates(startDate, endDate, positionDto.getCurrencySkey());
		//List<EntityAccountMapDefinition> kEAMDefns = eamRepo.findByEntitySkeyAndAccountType(positionDto.getEntitySkey(), ILMCoreConstants.KACCOUNT);
		if(CollectionUtils.isNotEmpty(mainEAMDefns)) {
			FundPositionDto fundPositionDto = new FundPositionDto();
			List<AccountBalanceAggregationDTO> aggrs = new ArrayList<>();
			List<AccountBalanceAggregationDTO> allAggrs = new ArrayList<>();
			positionDto.setEntityAcctMapSkeyMain(mainEAMDefns.get(0).getEntityAcctMapSkey());
			if(Objects.nonNull(startDate) && Objects.nonNull(endDate)) {
				if(startDate.isEqual(endDate)) {
					aggrs = paymentMessageDao.findFundPosition(positionDto, QueryConstants.GETPOSCUMULATIVEFUNDPOSN ,holidaysList);
				}else {
					aggrs = paymentMessageDao.findFundPosition(positionDto, QueryConstants.GETPOSCUMULATIVEFUNDPOSNPASTPERIOD,holidaysList);
					allAggrs = paymentMessageDao.findAllFundPosition(positionDto, QueryConstants.GETALLPOSCUMULATIVEFUNDPOSNPASTPERIOD,holidaysList);
					
				}
				fundPositionDto.setAggrs(getAmountsInMillions(aggrs));
				fundPositionDto.setAllAggrs(allAggrs);
				int weekDays = (int) DateUtil.noOfBusinessDays(startDate,endDate);
				int holidays = holidayRepo.getHolidays(startDate,endDate, positionDto.getCurrencySkey()).size();
				LOGGER.info("no of holidays : "+holidays);
				int diffInDays = weekDays - holidays ;
				LOGGER.info("Business days : "+ diffInDays);
				BigDecimal amnt = BigDecimal.ZERO;
				for(int row=0 ; row < fundPositionDto.getAllAggrs().size() ; row++) {
					amnt = amnt.add(fundPositionDto.getAllAggrs().get(row).getTotalAmnt());
				}
				if(diffInDays > 0) {
					fundPositionDto.setAvgPositive(amnt.divide(BigDecimal.valueOf(diffInDays), 2 , RoundingMode.HALF_UP));
				}
				else {
					fundPositionDto.setAvgPositive(null);
				}
				
			}
			cumulativePositions.put("LARGEST_POSITIVE", fundPositionDto);
		}	
		if(CollectionUtils.isNotEmpty(mainEAMDefns)) {
			FundPositionDto fundPositionDto = new FundPositionDto();
			List<AccountBalanceAggregationDTO> aggrs = new ArrayList<>();
			List<AccountBalanceAggregationDTO> allAggrs = new ArrayList<>();
			//Long eamSkeyK = kEAMDefns.get(0).getEntityAcctMapSkey();
			//positionDto.setEntityAcctMapSkeyK(eamSkeyK);
			positionDto.setEntityAcctMapSkeyMain(mainEAMDefns.get(0).getEntityAcctMapSkey());
			if(Objects.nonNull(startDate) && Objects.nonNull(endDate)) {
				if(startDate.isEqual(endDate)) {
					aggrs = paymentMessageDao.findFundPositionForNegativeCumulative(positionDto, QueryConstants.GETNEGCUMULATIVEFUNDPOSN,holidaysList);
				}else {
					aggrs = paymentMessageDao.findFundPositionForNegativeCumulative(positionDto, QueryConstants.GETNEGCUMULATIVEFUNDPOSNPASTPERIOD,holidaysList);
					allAggrs = paymentMessageDao.findAllFundPositionForNegativeCumulative(positionDto, QueryConstants.GETALLNEGCUMULATIVEFUNDPOSNPASTPERIOD,holidaysList);

				}
				fundPositionDto.setAggrs(getAmountsInMillions(aggrs));
				fundPositionDto.setAllAggrs(allAggrs);
				int weekDays = (int) DateUtil.noOfBusinessDays(startDate,endDate);
				int holidays = holidayRepo.getHolidays(startDate,endDate, positionDto.getCurrencySkey()).size();
				LOGGER.info("no of holidays : "+holidays);
				int diffInDays = weekDays - holidays ;
				LOGGER.info("Business days : "+ diffInDays);
				BigDecimal amnt = BigDecimal.ZERO;
				for(int row =0; row < fundPositionDto.getAllAggrs().size() ; row++) {
					amnt = amnt.add(fundPositionDto.getAllAggrs().get(row).getTotalAmnt());
				}
				if(diffInDays > 0) {
					fundPositionDto.setAvgNegative(amnt.divide(BigDecimal.valueOf(diffInDays), 2 , RoundingMode.HALF_UP));
				}
				else {
					fundPositionDto.setAvgNegative(null);
				}
			}
			//aggrs.stream().filter(p -> p.getEntityAcctMapSkey().compareTo(eamSkeyK) == 0).forEach(p -> p.setTotalAmnt(p.getTotalAmnt().negate()));
			cumulativePositions.put("LARGEST_NEGATIVE", fundPositionDto);
		}
		return cumulativePositions;
	}
}
