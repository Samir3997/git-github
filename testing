Payment Details:
http://10.172.120.19:8013/ilm-web/paymentPosition

{"analysisType":"SingleDay","countrySkey":1,"currencySkey":1,"entitySkey":1,"fromTime":"01-10-2024 00:00:00","nHighest":"1","paymentCase":1,"toTime":"02-10-2024 00:00:00","positionType":"lowest","paymentDisplayType":false}

{
    "timeSpendsInSeconds": 1,
    "status": "SUCCESS",
    "serviceName": "getNHighestIntraday",
    "t": {
        "sentPayments": {
            "2024-10-01T08:06:49.749": 992.5
        },
        "recievedPayments": null,
        "sentPastPeriodPayments": null,
        "recievedPastPeriodPayments": null,
        "average": null
    }
}


@Controller
@RequestMapping("/")
public class PaymentPositionController {
@PostMapping(value="/paymentPosition")
	@ResponseBody
	@CrossOrigin("${cors.urls}")
	public ResponseEntity<CommonResponseEntity<PaymentPosDTO>> getNHighestIntraday(@RequestBody PaymentPosParamsDTO paymentParams){
		PaymentPosDTO paymentPosDto=paymentPos.getPaymentDetails(paymentParams);
		LOGGER.info("PaymentPositionController {} getNHighestIntraday",paymentParams.getToTime());
		return new ResponseEntity<>(new CommonResponseEntity<PaymentPosDTO>(1l, "SUCCESS", "getNHighestIntraday", paymentPosDto),HttpStatus.OK);
	}
}

public interface PaymentPositionService {

	public PaymentPosDTO getPaymentDetails(PaymentPosParamsDTO paymentPosParams);
	}
	
	
	@Service
public class PaymentPositionServiceImpl implements PaymentPositionService {
@Override
	@Find(arguments = { "payment params DTO" }, returnType = "PaymentPositionDTo", type = "JSON")
	@FindNormEx
	public PaymentPosDTO getPaymentDetails(PaymentPosParamsDTO paymentPosParams) {
		PaymentPosDTO paymentPosDTO = new PaymentPosDTO();
		List<Long> entityMapSkey = getEntitySkey(paymentPosParams);
		// Condition for Single day PAyment and PastPeriod Payment
		if (paymentPosParams.getAnalysisType().equalsIgnoreCase(ILMCoreConstants.SINGLE_DAY)) {
			paymentPosDTO = singleDayPaymentAnalysis(paymentPosParams, entityMapSkey);
		} else if (paymentPosParams.getPaymentDisplayType()) {
			paymentPosDTO = individualPastPeriodPaymentAnalysis(paymentPosParams, entityMapSkey);
		} else {
			paymentPosDTO = pastPeriodPaymentAnalysis(paymentPosParams, entityMapSkey);
		}
		return paymentPosDTO;
	}
	
	private PaymentPosDTO singleDayPaymentAnalysis(PaymentPosParamsDTO paymentPosParams, List<Long> entityMapSkey) {
		Integer paymentCase = paymentPosParams.getPaymentCase();
		PaymentPosDTO paymentPosDTO = new PaymentPosDTO();
		Integer nHighest = paymentPosParams.getnHighest();
		LocalDateTime toDate = paymentPosParams.getToTime();
		LocalDateTime fromDate = paymentPosParams.getFromTime();
		List<LocalDate> holidaysList = holidayMasterRepo.getHolidayDates(fromDate.toLocalDate(), toDate.toLocalDate(), paymentPosParams.getCurrencySkey());
		List<AccountBalanceManagement> acctBalMgmt = new ArrayList<AccountBalanceManagement>();
		if (paymentPosParams.getPositionType().compareTo("highest") == 0) {
			switch (paymentCase) {
			case 0:
				acctBalMgmt = paymentPosDao.singleDayPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.plusSign, holidaysList);
				paymentPosDTO.setRecievedPayments(collectSingleDay(acctBalMgmt));
				break;
			case 1:
				acctBalMgmt = paymentPosDao.singleDayPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.negativeSign, holidaysList);
				paymentPosDTO.setSentPayments(collectSingleDay(acctBalMgmt));
				break;
			case 2:
				acctBalMgmt = paymentPosDao.singleDayPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.plusSign, holidaysList);
				paymentPosDTO.setRecievedPayments(collectSingleDay(acctBalMgmt));
				acctBalMgmt = paymentPosDao.singleDayPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.negativeSign, holidaysList);

				paymentPosDTO.setSentPayments(collectSingleDay(acctBalMgmt));
				break;
			}
		} else {
			switch (paymentCase) {
			case 0:
				acctBalMgmt = paymentPosDao.singleDayLowestPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.plusSign, holidaysList);
				paymentPosDTO.setRecievedPayments(collectSingleDay(acctBalMgmt));
				break;
			case 1:
				acctBalMgmt = paymentPosDao.singleDayLowestPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.negativeSign, holidaysList);
				paymentPosDTO.setSentPayments(collectSingleDay(acctBalMgmt));
				break;
			case 2:
				acctBalMgmt = paymentPosDao.singleDayLowestPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.plusSign, holidaysList);
				paymentPosDTO.setRecievedPayments(collectSingleDay(acctBalMgmt));
				acctBalMgmt = paymentPosDao.singleDayLowestPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.negativeSign, holidaysList);

				paymentPosDTO.setSentPayments(collectSingleDay(acctBalMgmt));
				break;
			}
		}
		return paymentPosDTO;
	}
	
	private PaymentPosDTO pastPeriodPaymentAnalysis(PaymentPosParamsDTO paymentPosParams, List<Long> entityMapSkey) {
		Integer paymentCase = paymentPosParams.getPaymentCase();
		PaymentPosDTO paymentPosDTO = new PaymentPosDTO();
		Integer nHighest = paymentPosParams.getnHighest();
		LocalDateTime toDate = paymentPosParams.getToTime();
		LocalDateTime fromDate = paymentPosParams.getFromTime();
		List<LocalDate> holidaysList = holidayMasterRepo.getHolidayDates(fromDate.toLocalDate(), toDate.toLocalDate(), paymentPosParams.getCurrencySkey());
		List<PastPosDTO> acctBalMgmt = new ArrayList<PastPosDTO>();
		if (paymentPosParams.getPositionType().compareTo("highest") == 0) {
			switch (paymentCase) {
			case 0:
				acctBalMgmt = paymentPosDao.pastPeriodPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.plusSign, holidaysList);
				paymentPosDTO.setRecievedPastPeriodPayments(collectfromDTO(acctBalMgmt));
				break;
			case 1:
				acctBalMgmt = paymentPosDao.pastPeriodPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.negativeSign, holidaysList);
				paymentPosDTO.setSentPastPeriodPayments(collectfromDTO(acctBalMgmt));
				break;
			case 2:
				acctBalMgmt = paymentPosDao.pastPeriodPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.plusSign, holidaysList);
				paymentPosDTO.setRecievedPastPeriodPayments(collectfromDTO(acctBalMgmt));
				acctBalMgmt = paymentPosDao.pastPeriodPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.negativeSign, holidaysList);
				paymentPosDTO.setSentPastPeriodPayments(collectfromDTO(acctBalMgmt));

				break;
			}
		} else {
			switch (paymentCase) {
			case 0:
				acctBalMgmt = paymentPosDao.pastPeriodLowestPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.plusSign, holidaysList);
				paymentPosDTO.setRecievedPastPeriodPayments(collectfromDTO(acctBalMgmt));
				break;
			case 1:
				acctBalMgmt = paymentPosDao.pastPeriodLowestPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.negativeSign, holidaysList);
				paymentPosDTO.setSentPastPeriodPayments(collectfromDTO(acctBalMgmt));
				break;
			case 2:
				acctBalMgmt = paymentPosDao.pastPeriodLowestPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.plusSign, holidaysList);
				paymentPosDTO.setRecievedPastPeriodPayments(collectfromDTO(acctBalMgmt));
				acctBalMgmt = paymentPosDao.pastPeriodLowestPayments(nHighest, toDate, fromDate, entityMapSkey,
						ILMCoreConstants.negativeSign, holidaysList);
				paymentPosDTO.setSentPastPeriodPayments(collectfromDTO(acctBalMgmt));

				break;
			}
		}

		return paymentPosDTO;

	}
}
