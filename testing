package com.maybank.ilm.core.swiftmsghandlers;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.maybank.ilm.core.dao.DimDao;
import com.maybank.ilm.core.dao.EntityAccountMappingRepo;
import com.maybank.ilm.core.util.ConversionUtil;
import com.maybank.ilm.core.util.ILMCoreConstants;
import com.maybank.ilm.dto.AccountBalanceMgmtDTO;
import com.maybank.ilm.entity.AccountBalanceAggregation;
import com.maybank.ilm.entity.AccountBalanceManagement;
import com.maybank.ilm.entity.EntityAccountMapDefinition;
import com.maybank.ilm.entity.FinMT103;
import com.prowidesoftware.swift.model.mx.MxCamt05400108;
import com.prowidesoftware.swift.model.mx.dic.EntryTransaction10;

@Component
public class MXcamt05400108Handler extends MXMsgHandlerAbstractImpl {
	private static final Logger LOGGER = LogManager.getLogger(MXcamt05400108Handler.class);

	@Autowired
	private EntityAccountMappingRepo eamRepo;

	@Autowired
	private DimDao dimDao;

	/**
	 * Instantiates a new MX camt05400108 parser.
	 *
	 */
	@Transactional
	@Override
	public <T> void saveToAcctBalMgmtAndMapping(T t, Long trackerId) {
		MxCamt05400108 camt05400108 = (MxCamt05400108) t;
		String actualMessageType = camt05400108.getMxId().toString();
		String currencyCode = camt05400108.getBkToCstmrDbtCdtNtfctn().getNtfctn().get(0).getNtry().get(0).getAmt().getCcy();
		String amountSign = "";
		String messageType ="";
		String counterParty = "";
		BigDecimal amount = camt05400108.getBkToCstmrDbtCdtNtfctn().getNtfctn().get(0).getNtry().get(0).getAmt().getValue();
		String creditDebitInd = camt05400108.getBkToCstmrDbtCdtNtfctn().getNtfctn().get(0).getNtry().get(0).getCdtDbtInd().value();
		LocalDateTime businessDtTime = LocalDateTime.now();
		String senderCode = camt05400108.getAppHdr().from().substring(0, 8);
		String receiverCode = camt05400108.getAppHdr().to().substring(0, 8);
		final EntryTransaction10 txDtls = camt05400108.getBkToCstmrDbtCdtNtfctn().getNtfctn().get(0).getNtry().get(0).getNtryDtls().get(0).getTxDtls().get(0);
		if(creditDebitInd.contentEquals(ILMCoreConstants.DBIT)) {
			amountSign = ILMCoreConstants.MINUS;
			messageType = ILMCoreConstants.MESSAGETYPE900;
			counterParty = this.extractCounterParty(txDtls.getAddtlTxInf());
		} else {
			amountSign = ILMCoreConstants.PLUS;
			messageType = ILMCoreConstants.MESSAGETYPE910;
		}
		List<AccountBalanceManagement> allEntries = new ArrayList<>();
		List<AccountBalanceAggregation> aggregations = new ArrayList<>();
		if(currencyCode.equals(ILMCoreConstants.MYR)) {
			String sendersRef = camt05400108.getBkToCstmrDbtCdtNtfctn().getNtfctn().get(0).getNtry().get(0)
					.getNtryDtls().get(0).getTxDtls().get(0).getRefs().getEndToEndId();
			LocalDate valueDate = LocalDate
					.parse(camt05400108.getBkToCstmrDbtCdtNtfctn().getNtfctn().get(0).getNtry().get(0).getNtryDtls()
							.get(0).getTxDtls().get(0).getRltdDts().getIntrBkSttlmDt().toString());
			final String accountNo = this.extractAccountNumber(camt05400108, creditDebitInd, txDtls, currencyCode, valueDate);
			final EntityAccountMapDefinition eamDefnIn = getEntityAcctMapDefnByAcctNum(accountNo, currencyCode);
			if (eamDefnIn != null) {
				LOGGER.info("Entity account mapping found for {}", accountNo);
				Long entityAcctMapSkey = eamDefnIn.getEntityAcctMapSkey();
				final String addtlTxInf = txDtls.getAddtlTxInf();
				final String trnCode = this.extractFromAddlTxInf(addtlTxInf,"TRN");
				System.out.println(trnCode);
				AccountBalanceManagement mgmt = new AccountBalanceManagement(entityAcctMapSkey, amount, amountSign, trackerId,
						businessDtTime, valueDate, null, messageType, senderCode, receiverCode, counterParty, trnCode, sendersRef,
						currencyCode, null,null,actualMessageType);
				System.out.println(mgmt);
				allEntries.add(mgmt);
				createEntriesForICRU(allEntries,mgmt,camt05400108,addtlTxInf);
			} else {
				LOGGER.info("Entity defination not found for {} {} {} ", accountNo,
						ILMCoreConstants.MAINACCOUNT, currencyCode);
				throwEntityNotFountException();
			}
			
		}else {
			LOGGER.info("creditDebitIndicator: {}", creditDebitInd);
			LOGGER.info("Inside MXcamt05400108Handler for Nostro {}.", currencyCode);
			EntityAccountMapDefinition eamDefn = getDefnByEntityIDAndAcctType(senderCode,
					ILMCoreConstants.NOSTROACCOUNT, currencyCode);
			if (eamDefn != null) {
				LocalDate valueDate=LocalDate.parse(camt05400108.getBkToCstmrDbtCdtNtfctn().getNtfctn().get(0).getNtry().get(0).getValDt().getDt().toString());
				String sendersRef=camt05400108.getBkToCstmrDbtCdtNtfctn().getGrpHdr().getMsgId();
				Long entityAcctMapSkey = eamDefn.getEntityAcctMapSkey();
				Character settled = ILMCoreConstants.NIND;
				if (checkRelatedRefForNostro(valueDate, entityAcctMapSkey, sendersRef)) {
					settled = ILMCoreConstants.YIND;
				}
				AccountBalanceManagement mgmt = new AccountBalanceManagement(entityAcctMapSkey, amount, amountSign,
						trackerId, businessDtTime, valueDate, null, messageType, senderCode, receiverCode, null,
						sendersRef, currencyCode, ILMCoreConstants.NIND, settled, actualMessageType);
				allEntries.add(mgmt);

			} else {
				LOGGER.info("Entity defination not found for {} {} {} ", senderCode, ILMCoreConstants.NOSTROACCOUNT,
						currencyCode);
				throwEntityNotFountException();
			}
		}
		String aggrInd = ILMCoreConstants.OTHERS;
		getAggregations(allEntries, aggregations, aggrInd);
		saveEntitiesForMX(allEntries);
		
	}
	
	private void createEntriesForICRU(List<AccountBalanceManagement> icruEntries, AccountBalanceManagement mgmt, MxCamt05400108 camt05400108, String addtlTxInf) {
		String sIcruAmnt = this.extractFromAddlTxInf(addtlTxInf, "ICRU");
		if (sIcruAmnt != null) {
			AccountBalanceManagement kAcctEntry = setICRUEntry(camt05400108, sIcruAmnt,mgmt, ILMCoreConstants.KACCOUNT);
			icruEntries.add(kAcctEntry);
		}
	}
	
	private AccountBalanceManagement setICRUEntry(MxCamt05400108 camt05400108, String sIcruAmnt, AccountBalanceManagement mgmt, String acctName) {
		BigDecimal icruAmnt = ConversionUtil.convertStrToBigDecimal(sIcruAmnt);
		String  entityBic = camt05400108.getBkToCstmrDbtCdtNtfctn().getNtfctn().get(0).getNtry().get(0).getNtryDtls()
						.get(0).getTxDtls().get(0).getRltdPties().getDbtr().getPty().getId().getOrgId().getAnyBIC();
		EntityAccountMapDefinition eamDefn = getDefnByEntityIDAndAcctType(entityBic, acctName, ILMCoreConstants.MYR);
		AccountBalanceManagement icruEntry = null;
		if(eamDefn != null) {
			icruEntry = new AccountBalanceManagement(eamDefn.getEntityAcctMapSkey(), icruAmnt, ILMCoreConstants.PLUS, mgmt.getTrackerID(),
					getCurrentDateTimeByZone(), mgmt.getValueDate(), null, mgmt.getMessageType(), entityBic, null, null, mgmt.getTrnCode(), mgmt.getSendersRef(),
					ILMCoreConstants.MYR, null,null,camt05400108.getMxId().toString());
		}else {
			LOGGER.info("Entity defination not found for {} {} {}", entityBic, acctName, ILMCoreConstants.MYR);
		}
		
		return icruEntry;
	}

	private String extractAccountNumber(final MxCamt05400108 camt05400108, final String creditDebitInd, final EntryTransaction10 txDtls
			, final String currencyCode, final LocalDate valueDate) {
		if(creditDebitInd.contentEquals(ILMCoreConstants.DBIT)) {
			return /*this.checkRelatedRefOfCamt054(valueDate, txDtls.getRefs().getEndToEndId(), currencyCode)
			.map(mgmt -> {
				return this.getDefnByEntityIDAndAcctType(txDtls.getRltdPties().getDbtr().getPty().getId().getOrgId().getAnyBIC()
						, ILMCoreConstants.SRRACCOUNT, currencyCode).getAccountNumber();
			})
			.orElseGet(() -> {
				return txDtls.getRltdPties().getDbtrAcct().getId().getOthr().getId();
			});*/Optional.ofNullable( 
					Optional.ofNullable(this.extractFromAddlTxInf(txDtls.getAddtlTxInf(), "PAYA"))
			.orElseGet(() ->  this.getDefnByEntityIDAndAcctType(this.extractFromAddlTxInf(txDtls.getAddtlTxInf(), "PAYB")
					, ILMCoreConstants.MAINACCOUNT, currencyCode).getAccountNumber()))
			.orElseGet(() -> txDtls.getRltdPties().getDbtrAcct().getId().getOthr().getId());
			
		} else {
			return Optional.ofNullable(this.extractFromAddlTxInf(txDtls.getAddtlTxInf(), "CPRA"))
			.orElseGet(() -> camt05400108.getBkToCstmrDbtCdtNtfctn().getNtfctn().get(0).getAcct().getId().getOthr().getId());
		}
	}

	private String extractFromAddlTxInf(final String addtlTxInf,final String ind) {
		final List<String> segs = Arrays.asList(addtlTxInf.split("/"));
		final Integer index = segs.indexOf(ind);
		if(index != -1) {
			final String result = StringUtils.trimToNull(segs.get(index + 1));
			LOGGER.info("AddtlTxInf {} {}", ind, result);
			return result;
		}
		return null;
	}
	
	private String extractCounterParty(final String addtlTxInf) {
		String bic = this.extractFromAddlTxInf(addtlTxInf, "CPRB");
		if(bic != null) {
			return bic;
		} else {
			String acctNo = this.extractFromAddlTxInf(addtlTxInf, "CPRA");
			String bicFromAcctNo = eamRepo.findByAccountNumber(acctNo) != null ? eamRepo.findByAccountNumber(acctNo).getEntityIdentifier() : null;
			return bicFromAcctNo;
		}
	}

	@Override
	public String getMessageType() {
		return ILMCoreConstants.MXTYPECAMT05400108;
	}

	@Override
	public <T> AccountBalanceMgmtDTO validateMessage(T t) {
		FinMT103 finMT103 = (FinMT103) t;
		return super.validateMessage(finMT103.getTags57().getBlock4Tag57aBic(), finMT103.getTags72(),
				finMT103.getBlock1().getBlock1LogicalTerminal(), finMT103.getBlock4().getBlock4Tag32aCurrency(),
				finMT103.getBlock4().getBlock4Tag32aDate(), finMT103.getBlock4().getBlock4Tag20(),
				ILMCoreConstants.MESSAGETYPE103, finMT103.getBlock4().getBlock4Tag32aSettledAmnt(), null, Boolean.TRUE);
	}
}

















package com.maybank.ilm.core.swiftmsghandlers;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.StringUtils;

import com.maybank.ilm.core.dao.AccountBalanceAggrRepo;
import com.maybank.ilm.core.dao.AccountBalanceMgmtRepo;
import com.maybank.ilm.core.dao.CashflowProjectionDao;
import com.maybank.ilm.core.dao.DimDao;
import com.maybank.ilm.core.dao.EntityAccountMappingRepo;
import com.maybank.ilm.core.dao.FinMessageDao;
import com.maybank.ilm.core.dao.KAccountConfigRepo;
import com.maybank.ilm.core.dao.LockConfigDao;
import com.maybank.ilm.core.dao.LockConfigRepo;
import com.maybank.ilm.core.service.EntityAccountMappingService;
import com.maybank.ilm.core.service.IlmAbstractMessageHandler;
import com.maybank.ilm.core.util.ConversionUtil;
import com.maybank.ilm.core.util.DateUtil;
import com.maybank.ilm.core.util.ExceptionUtil;
import com.maybank.ilm.core.util.ILMCoreConstants;
import com.maybank.ilm.dto.AccountBalanceMgmtDTO;
import com.maybank.ilm.dto.KAccountRedemptionDTO;
import com.maybank.ilm.embeddable.Block4Tag72;
import com.maybank.ilm.entity.AccountBalanceAggregation;
import com.maybank.ilm.entity.AccountBalanceManagement;
import com.maybank.ilm.entity.DimCurrency;
import com.maybank.ilm.entity.EntityAccountMapDefinition;
import com.maybank.ilm.entity.FinMT940;
import com.maybank.ilm.entity.KAccountConfiguration;
import com.maybank.ilm.entity.MTField;
import com.maybank.ilm.entity.MTSequence;
import com.maybank.ilm.utility.exception.ExceptionConstants;
import com.maybank.ilm.utility.exception.ILMException;

public abstract class MXMsgHandlerAbstractImpl extends IlmAbstractMessageHandler implements MXMessageHandler{
	
	private static final Logger LOGGER = LogManager.getLogger(MXMsgHandlerAbstractImpl.class);
	
	@Autowired
	private EntityAccountMappingService entityAcctMapService;
	
	@Autowired
	private FinMessageDao finMsgDao;
	
	@Autowired
	private CashflowProjectionDao cfProjectionDao;
	
	@Autowired
	private AccountBalanceMgmtRepo mgmtRepo;
	
	@Autowired
	private AccountBalanceAggrRepo aggrRepo;
	
	@Autowired
	private EntityAccountMappingRepo eamRepo;
	
	@Autowired
	private KAccountConfigRepo kAccountConfigRepo;
	
	@Autowired
	private DimDao dimDao;
	
	@Autowired
	private LockConfigDao lockConfigDao;
	
	@Autowired
	private LockConfigRepo lockConfigRepo;
	
	public final EntityAccountMapDefinition getDefnByEntityIDAndAcctType(String entityID, String acctType, String currencyCode) {
		EntityAccountMapDefinition definition = null;
		DimCurrency dimCurrency = getDimCurrency(currencyCode);
		if(dimCurrency != null)
			definition = eamRepo.findFirstByEntityIdentifierAndAccountTypeAndCurrencySkey(entityID, acctType, dimCurrency.getCurrencySkey());
		return definition;
	}
	
	public final EntityAccountMapDefinition getEntityAcctMapDefnByAcctNum(String acctNum, String currencyCode) {
		EntityAccountMapDefinition definition = null;
		DimCurrency dimCurrency = getDimCurrency(currencyCode);
		if(dimCurrency != null)
			definition = entityAcctMapService.getEntityAcctMapDefnByAcctNum(acctNum, dimCurrency.getCurrencySkey());
		return definition;
	}

	private DimCurrency getDimCurrency(String currencyCode) {
		return dimDao.getCurrDetailsByCode(currencyCode);
	}
	
	
}







package com.maybank.ilm.core.service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.commons.collections4.CollectionUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.maybank.ilm.anno.Find;
import com.maybank.ilm.anno.FindNormEx;
import com.maybank.ilm.core.dao.EntityAccountMappingDao;
import com.maybank.ilm.core.dao.EntityAccountMappingRepo;
import com.maybank.ilm.core.util.ILMCoreConstants;
import com.maybank.ilm.entity.EntityAccountMapDefinition;

@Service
public class EntityAccountMappingServiceImpl implements EntityAccountMappingService{

	@Autowired
	EntityAccountMappingDao mappingDao;

	@Autowired
	EntityAccountMappingRepo entityAcctMapRepo;

	@Override
	@Find(arguments= {"CountryId","List EntityId","ListCurrencyId"},type="JSON",comment="entity_by_dim")
	@FindNormEx
	public List<EntityAccountMapDefinition> getEntityAcctMapByDims(List<Long> countrySkeys, List<Long> entitySkeys, List<Long> currencySkeys){
		return mappingDao.getEntityAcctMapByDims(countrySkeys, entitySkeys, currencySkeys);
	}

	@Override
	@Find(arguments= {"acct Number","currencyID"},returnType="entity acct map defn",comment="entity_by_accno")
	@FindNormEx
	public EntityAccountMapDefinition getEntityAcctMapDefnByAcctNum(String acctNum, Long currencySkey){
		return mappingDao.getEntityAcctMapDefnByAcctNum(acctNum, currencySkey);
	}

	@Override
	@Find(arguments= {"entityId,Acct Type"},returnType="Entity Acct Map Defn",comment="entity_by_id_type")
	@FindNormEx
	public EntityAccountMapDefinition getEntityAcctMapDefnByEntityIDAndAcctType(String entityID, String acctType) {
		return mappingDao.getEntityAcctMapDefnByEntityIDAndAcctType(entityID, acctType);
	}

	@Override
	@Find(arguments= {"Mapping Defn"},returnType="DEFN exists or Not",type="JSON",comment="entity_by_def")
	@FindNormEx
	public String saveEntityAcctMapDefns(EntityAccountMapDefinition mapDefn) {
		String message = ILMCoreConstants.SAVEDSUCCESS;
		List<EntityAccountMapDefinition> existingDefns = getEntityAcctMapByDims(new ArrayList<Long>(Arrays.asList(mapDefn.getCountrySkey())), 
				new ArrayList<Long>(Arrays.asList(mapDefn.getEntitySkey())), new ArrayList<Long>(Arrays.asList(mapDefn.getCurrencySkey())));
		Boolean matched = Boolean.FALSE;
		Boolean existingMainAgent = Boolean.FALSE;
		if("Main Agent".equals(mapDefn.getTypeOfNostroAgent())) {
			existingMainAgent = existingDefns.stream().filter(eamDefn -> eamDefn.getTypeOfNostroAgent().equals("Main Agent"))
					.findFirst().isPresent();
		}
		if(CollectionUtils.isNotEmpty(existingDefns) && !existingMainAgent) {
			for(EntityAccountMapDefinition defn : existingDefns) {
				if(defn.equals(mapDefn)) {
					matched = Boolean.TRUE;
				}
			}
		}
		if(existingMainAgent) {
			message = ILMCoreConstants.DEFNEXISTSMAINAGENT;
		} else if(Boolean.TRUE.equals(matched)) {
			message = ILMCoreConstants.DEFNEXISTS;
		} else {
			mappingDao.saveAny(mapDefn);
		}
		return message;
	}

	@Override
	@Find(arguments= {"List of Entity Acct Map Defn"},returnType="void",type="JSON",comment="update_entity")
	@FindNormEx
	public String updateEntityAcctMapDefn(EntityAccountMapDefinition mapDefn) {
		String message = ILMCoreConstants.SAVEDSUCCESS;
		List<EntityAccountMapDefinition> existingDefns = entityAcctMapRepo.getDefnByNostroInd('Y');
		Boolean matched = Boolean.FALSE;
		AtomicBoolean existingMainAgent = new AtomicBoolean(Boolean.FALSE);
		if("Main Agent".equals(mapDefn.getTypeOfNostroAgent())) {
					existingDefns.stream().filter(eamDefn -> eamDefn.getEntityAcctMapSkey().equals(mapDefn.getEntityAcctMapSkey()))
					.findFirst()
					.filter(eamDefn -> "Sub Agent".equals(eamDefn.getTypeOfNostroAgent()))
					.ifPresent(eamDefn -> {
						existingMainAgent.set(existingDefns.stream().filter(eamDefn2 -> eamDefn2.getTypeOfNostroAgent().equals("Main Agent"))
								.findFirst().isPresent());
					});
		}
		if(CollectionUtils.isNotEmpty(existingDefns) && !existingMainAgent.get()) {
			for(EntityAccountMapDefinition defn : existingDefns) {
				if(!defn.getEntityAcctMapSkey().equals(mapDefn.getEntityAcctMapSkey()) && defn.getAccountNumber().equals(mapDefn.getAccountNumber())) {
					matched = Boolean.TRUE;
				}
			}
		}
		if(existingMainAgent.get()) {
			message = ILMCoreConstants.DEFNEXISTSMAINAGENT;
		} else if(Boolean.TRUE.equals(matched)) {
			message = ILMCoreConstants.DEFNEXISTS;
		} else {
			mappingDao.updateAny(mapDefn);
		}
		return message;
	}

	@Override
	@Find(arguments= {"List of Entity Acct Map Id"},type="JSON",comment="delete_entity_skeys")
	@FindNormEx
	public void deleteEntityAcctMap(List<Long> skeys) {
		for(Long skey : skeys) {
			entityAcctMapRepo.deleteById(skey);
		}
	}

	@Override
	@Find(arguments= {},returnType="List of Entity Acct Map",type="JSON")
	@FindNormEx
	public List<EntityAccountMapDefinition> getEntityAcctMapDefnByNostro() {
		List<EntityAccountMapDefinition> defns=entityAcctMapRepo.getDefnByNostroInd('Y');
		return defns;
	}
}
